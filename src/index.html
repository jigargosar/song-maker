<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elm + Parcel App</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <div id="root"></div>

    <!-- Load piano instrument data from CDN -->
    <script src='https://surikov.github.io/webaudiofontdata/sound/0250_SoundBlasterOld_sf2.js'></script>

    <!-- Load WebAudioFont player from CDN -->
    <script src='https://surikov.github.io/webaudiofont/npm/dist/WebAudioFontPlayer.js'></script>

    <script type="module">
        import { Elm } from "./Main.elm";

        // Capture globals as clean constants
        const WebAudioFontPlayer = window.WebAudioFontPlayer;
        const piano = window._tone_0250_SoundBlasterOld_sf2;

        // Initialize Elm
        const app = Elm.Main.init({ node: document.getElementById("root") });

        // Initialize WebAudioFont
        const audioContext = new AudioContext();
        const player = new WebAudioFontPlayer();

        // Use the captured constants
        player.loader.decodeAfterLoading(audioContext, piano);

        // Start time sync to Elm for display (lower frequency for smoother display)
        setInterval(() => {
            app.ports.timeSync.send(audioContext.currentTime);
        }, 10); // 10Hz updates for display


        app.ports.playChord.subscribe((data) => {
            const { notes, when } = data;
            logSPM(when);
            notes.forEach(noteData => {
                const { note, duration, volume } = noteData;
                player.queueWaveTable(audioContext, audioContext.destination,
                    piano, when, note, duration, volume);
            });
        });

        // Wake audio context on user interaction
        app.ports.wakeAudioContext.subscribe(() => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        });

        // Horizontal scroll-to-active-step port handler
        app.ports.scrollToActiveStep.subscribe(({ containerId, headerId }) => {
            const container = document.getElementById(containerId);
            const header = document.getElementById(headerId);
            if (container && header) {
                const containerRect = container.getBoundingClientRect();
                const headerRect = header.getBoundingClientRect();
                // Calculate the left position of the header relative to the container's scroll area
                const left = headerRect.left - containerRect.left + container.scrollLeft;
                // Center the header horizontally in the container
                container.scrollLeft = left - (container.clientWidth / 2) + (header.clientWidth / 2);
            }
        });

        // SPM logging helper at end of script, inside <script>
        function logSPM(when) {
            if (!window._spmDebug) {
                window._spmDebug = { prevWhen: null, intervals: [] };
            }
            if (window._spmDebug.prevWhen !== null) {
                const interval = when - window._spmDebug.prevWhen;
                window._spmDebug.intervals.push(interval);
                if (window._spmDebug.intervals.length > 20) {
                    window._spmDebug.intervals.shift();
                }
                const avgInterval = window._spmDebug.intervals.reduce((a, b) => a + b, 0) / window._spmDebug.intervals.length;
                const runningSPM = avgInterval > 0 ? 60 / avgInterval : 0;
                console.log(`[SPM Debug] Scheduled interval: ${interval.toFixed(3)}s, Running avg SPM: ${runningSPM.toFixed(2)}`);
            }
            window._spmDebug.prevWhen = when;
        }
    </script>
</body>
</html>
